workflows:
  debug_apk:
    name: Debug APK (self-contained)
    max_build_duration: 60
    environment:
      flutter: stable
      vars:
        APP_NAME: notice_app
        PACKAGE_NAME: com.example.notice_app
    scripts:
      - name: Create/overwrite Flutter project
        script: |
          SAFE_NAME="${APP_NAME// /_}"
          SAFE_NAME="$(echo "$SAFE_NAME" | tr '[:upper:]' '[:lower:]')"
          SAFE_NAME="$(echo "$SAFE_NAME" | sed 's/[^a-z0-9_]/_/g')"
          if [[ "$SAFE_NAME" =~ ^[0-9] ]]; then SAFE_NAME="app_$SAFE_NAME"; fi
          echo "Using project name: $SAFE_NAME"
          flutter create --org "${PACKAGE_NAME}" --project-name "$SAFE_NAME" --overwrite .

      - name: Add main.dart (use repo if exists; otherwise write full Notes app)
        script: |
          mkdir -p lib
          if [ -f "$CM_SOURCE_DIR/lib/main.dart" ]; then
            echo "✅ Found lib/main.dart in repo — using it"
            cp -f "$CM_SOURCE_DIR/lib/main.dart" lib/main.dart
          else
            echo "⚠️ No lib/main.dart in repo. Writing full Notes app (with colors & persistence)..."
            : > lib/main.dart
            printf "%s\n" \
"import 'dart:convert';" \
"import 'package:flutter/material.dart';" \
"import 'package:shared_preferences/shared_preferences.dart';" \
"" \
"void main() {" \
"  WidgetsFlutterBinding.ensureInitialized();" \
"  runApp(const NotesApp());" \
"}" \
"" \
"class NotesApp extends StatelessWidget {" \
"  const NotesApp({super.key});" \
"  @override" \
"  Widget build(BuildContext context) {" \
"    return MaterialApp(" \
"      debugShowCheckedModeBanner: false," \
"      title: 'Заметки'," \
"      theme: ThemeData(useMaterial3: true, colorScheme: ColorScheme.fromSeed(seedColor: Colors.indigo))," \
"      darkTheme: ThemeData.dark(useMaterial3: true)," \
"      home: const NotesHomePage()," \
"    );" \
"  }" \
"}" \
"" \
"class Note {" \
"  String id;" \
"  String text;" \
"  bool pinned;" \
"  int? colorHex;" \
"  int updatedAt;" \
"  Note({required this.id, required this.text, this.pinned=false, this.colorHex, required this.updatedAt});" \
"  factory Note.newNote() => Note(id: DateTime.now().microsecondsSinceEpoch.toString(), text:'', updatedAt: DateTime.now().millisecondsSinceEpoch);" \
"  Map<String, dynamic> toJson()=>{'id':id,'text':text,'pinned':pinned,'colorHex':colorHex,'updatedAt':updatedAt};" \
"  static Note fromJson(Map<String,dynamic> j)=>Note(id:j['id'], text:j['text'], pinned:j['pinned']??false, colorHex:j['colorHex'], updatedAt:j['updatedAt']??0);" \
"}" \
"" \
"class NotesStore extends ChangeNotifier {" \
"  static const _k='notes_v1_colors';" \
"  final List<Note> _items=[];" \
"  bool _loaded=false;" \
"  bool get isLoaded=>_loaded;" \
"  List<Note> get items=>List.unmodifiable(_items);" \
"  Future<void> load() async {" \
"    final p=await SharedPreferences.getInstance();" \
"    final raw=p.getString(_k);" \
"    if(raw!=null){" \
"      final list=(jsonDecode(raw) as List).cast<Map<String,dynamic>>().map(Note.fromJson).toList();" \
"      _items..clear()..addAll(list);" \
"    }" \
"    _loaded=true; notifyListeners();" \
"  }" \
"  Future<void> _save() async {" \
"    final p=await SharedPreferences.getInstance();" \
"    await p.setString(_k, jsonEncode(_items.map((e)=>e.toJson()).toList()));" \
"  }" \
"  Future<void> add(Note n) async { _items.add(n); await _save(); notifyListeners(); }" \
"  Future<void> update(Note n) async { final i=_items.indexWhere((x)=>x.id==n.id); if(i!=-1){ _items[i]=n..updatedAt=DateTime.now().millisecondsSinceEpoch; await _save(); notifyListeners(); } }" \
"  Future<void> remove(String id) async { _items.removeWhere((n)=>n.id==id); await _save(); notifyListeners(); }" \
"  Future<void> togglePin(String id) async { final i=_items.indexWhere((x)=>x.id==id); if(i!=-1){ final n=_items[i]; n.pinned=!n.pinned; n.updatedAt=DateTime.now().millisecondsSinceEpoch; await _save(); notifyListeners(); } }" \
"}" \
"" \
"class NotesHomePage extends StatefulWidget { const NotesHomePage({super.key}); @override State<NotesHomePage> createState()=>_NotesHomePageState(); }" \
"class _NotesHomePageState extends State<NotesHomePage> {" \
"  final store=NotesStore();" \
"  bool searching=false; final _search=TextEditingController();" \
"  @override void initState(){ super.initState(); store.addListener(()=>setState((){})); store.load(); }" \
"  @override void dispose(){ store.dispose(); _search.dispose(); super.dispose(); }" \
"  List<Note> get _visible{" \
"    final q=_search.text.trim().toLowerCase();" \
"    final list = q.isEmpty? store.items : store.items.where((n)=>n.text.toLowerCase().contains(q)).toList();" \
"    list.sort((a,b){ if(a.pinned!=b.pinned) return b.pinned?1:-1; return b.updatedAt.compareTo(a.updatedAt); });" \
"    return list;" \
"  }" \
"  Future<void> _edit({Note? src}) async {" \
"    final res = await showModalBottomSheet<Note>(" \
"      context: context," \
"      isScrollControlled: true, showDragHandle: true," \
"      builder: (_) => NoteEditor(note: src)," \
"    );" \
"    if(res==null) return;" \
"    if(src==null) await store.add(res); else await store.update(res);" \
"  }" \
"  @override Widget build(BuildContext context){" \
"    final notes=_visible;" \
"    return Scaffold(" \
"      appBar: AppBar(" \
"        title: searching" \
"          ? TextField(controller:_search, autofocus:true, decoration: const InputDecoration(hintText:'Поиск…', isDense:true), onChanged:(_)=>setState((){}))" \
"          : const Text('Заметки')," \
"        actions: [IconButton(onPressed:(){ setState((){ searching=!searching; if(!searching) _search.clear();}); }, icon: Icon(searching? Icons.close: Icons.search))]," \
"      )," \
"      body: !store.isLoaded" \
"        ? const Center(child:CircularProgressIndicator())" \
"        : notes.isEmpty" \
"          ? const _EmptyState()" \
"          : ListView.builder(padding: const EdgeInsets.symmetric(vertical:8), itemCount: notes.length, itemBuilder:(c,i){" \
"              final n=notes[i];" \
"              return Dismissible(" \
"                key: ValueKey(n.id)," \
"                background: _swipeBg(context, left:true)," \
"                secondaryBackground: _swipeBg(context, left:false)," \
"                onDismissed:(_)=> store.remove(n.id)," \
"                child: _NoteTile(note:n, onEdit: ()=>_edit(src:n), onTogglePin: ()=>store.togglePin(n.id), onDelete: ()=>store.remove(n.id))," \
"              );" \
"            })," \
"      floatingActionButton: FloatingActionButton.extended(onPressed: ()=>_edit(), icon: const Icon(Icons.add), label: const Text('Новая'))," \
"    );" \
"  }" \
"}" \
"" \
"Widget _swipeBg(BuildContext context, {required bool left}) => Container(" \
"  margin: const EdgeInsets.symmetric(horizontal:12, vertical:6)," \
"  decoration: BoxDecoration(color: Theme.of(context).colorScheme.errorContainer, borderRadius: BorderRadius.circular(16))," \
"  alignment: left? Alignment.centerLeft: Alignment.centerRight," \
"  padding: EdgeInsets.only(left: left?24:0, right: left?0:24)," \
"  child: const Icon(Icons.delete)," \
");" \
"" \
"class _EmptyState extends StatelessWidget{" \
"  const _EmptyState();" \
"  @override Widget build(BuildContext context)=> Center(child: Padding(padding: const EdgeInsets.all(24), child: Column(mainAxisSize: MainAxisSize.min, children:[" \
"    const Icon(Icons.note_alt_outlined, size:72)," \
"    const SizedBox(height:16)," \
"    const Text('Нет заметок', style: TextStyle(fontSize:20, fontWeight: FontWeight.w600))," \
"    const SizedBox(height:8)," \
"    Text('Нажми «Новая», чтобы создать первую запись.', style: Theme.of(context).textTheme.bodyMedium, textAlign: TextAlign.center)," \
"  ]))); }" \
"" \
"class _NoteTile extends StatelessWidget{" \
"  final Note note; final VoidCallback onEdit; final VoidCallback onTogglePin; final VoidCallback onDelete;" \
"  const _NoteTile({required this.note, required this.onEdit, required this.onTogglePin, required this.onDelete});" \
"  @override Widget build(BuildContext context){" \
"    final color = note.colorHex!=null? Color(note.colorHex!): null;" \
"    final updated = DateTime.fromMillisecondsSinceEpoch(note.updatedAt);" \
"    return Card(margin: const EdgeInsets.symmetric(horizontal:12, vertical:6), shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16))," \
"      child: InkWell(onTap:onEdit, borderRadius: BorderRadius.circular(16), child: Row(crossAxisAlignment: CrossAxisAlignment.stretch, children:[" \
"        Container(width:6, decoration: BoxDecoration(color: color??Colors.transparent, borderRadius: const BorderRadius.only(topLeft: Radius.circular(16), bottomLeft: Radius.circular(16))))," \
"        Expanded(child: Padding(padding: const EdgeInsets.all(12), child: Row(crossAxisAlignment: CrossAxisAlignment.start, children:[" \
"          if(note.pinned) const Padding(padding: EdgeInsets.only(top:4, right:8), child: Icon(Icons.push_pin, size:18))," \
"          Expanded(child: Column(crossAxisAlignment: CrossAxisAlignment.start, children:[" \
"            Row(children:[" \
"              Expanded(child: Text(_firstLine(note.text).isEmpty? 'Без названия': _firstLine(note.text), maxLines:1, overflow: TextOverflow.ellipsis, style: const TextStyle(fontWeight: FontWeight.w600, fontSize:16)))," \
"              if(color!=null) Container(width:14, height:14, margin: const EdgeInsets.only(left:8), decoration: BoxDecoration(color: color, shape: BoxShape.circle, border: Border.all(color: Theme.of(context).colorScheme.outlineVariant)))," \
"            ])," \
"            const SizedBox(height:6)," \
"            Text(_restText(note.text), maxLines:3, overflow: TextOverflow.ellipsis)," \
"            const SizedBox(height:8)," \
"            Row(children:[" \
"              Icon(Icons.access_time, size:14, color: Theme.of(context).textTheme.bodySmall?.color)," \
"              const SizedBox(width:4)," \
"              Text('Обновлено: ' + _format(updated), style: Theme.of(context).textTheme.bodySmall)," \
"            ])," \
"          ]))," \
"          const SizedBox(width:8)," \
"          Column(children:[" \
"            IconButton(tooltip: note.pinned? 'Открепить':'Закрепить', onPressed:onTogglePin, icon: Icon(note.pinned? Icons.push_pin: Icons.push_pin_outlined))," \
"            IconButton(tooltip:'Удалить', onPressed:onDelete, icon: const Icon(Icons.delete_outline))," \
"          ])," \
"        ])))," \
"      ]))," \
"    );" \
"  }" \
"}" \
"" \
"class NoteEditor extends StatefulWidget{" \
"  final Note? note; const NoteEditor({super.key, this.note}); @override State<NoteEditor> createState()=>_NoteEditorState();" \
"}" \
"class _NoteEditorState extends State<NoteEditor>{" \
"  late final TextEditingController _ctrl; Color? _color;" \
"  @override void initState(){ super.initState(); _ctrl=TextEditingController(text: widget.note?.text??''); _color = widget.note?.colorHex!=null? Color(widget.note!.colorHex!): null; }" \
"  @override void dispose(){ _ctrl.dispose(); super.dispose(); }" \
"  @override Widget build(BuildContext context){" \
"    final isNew = widget.note==null;" \
"    return Padding(padding: EdgeInsets.only(bottom: MediaQuery.of(context).viewInsets.bottom+16, left:16, right:16, top:8), child: Column(mainAxisSize: MainAxisSize.min, children:[" \
"      Row(children:[" \
"        Text(isNew? 'Новая заметка':'Редактирование', style: Theme.of(context).textTheme.titleLarge)," \
"        const Spacer()," \
"        IconButton(tooltip:'Вставить текущую дату', onPressed: (){" \
"          final now=DateTime.now();" \
"          final s='${_pad(now.day)}.${_pad(now.month)}.${now.year} ${_pad(now.hour)}:${_pad(now.minute)}';" \
"          final sel=_ctrl.selection; final t=_ctrl.text;" \
"          final inserted=t.replaceRange(sel.start>=0? sel.start: t.length, sel.end>=0? sel.end: t.length, s);" \
"          _ctrl.text=inserted; _ctrl.selection= TextSelection.collapsed(offset: (sel.start>=0? sel.start: t.length)+s.length);" \
"        }, icon: const Icon(Icons.calendar_month))," \
"      ])," \
"      const SizedBox(height:8)," \
"      Align(alignment: Alignment.centerLeft, child: Wrap(spacing:8, runSpacing:8, crossAxisAlignment: WrapCrossAlignment.center, children:[" \
"        _ColorDot(color:null, selected:_color==null, onTap: ()=> setState(()=> _color=null), label:'Без цвета')," \
"        for(final c in _palette()) _ColorDot(color:c, selected:_color?.value==c.value, onTap: ()=> setState(()=> _color=c))," \
"      ]))," \
"      const SizedBox(height:12)," \
"      TextField(controller:_ctrl, autofocus:true, minLines:6, maxLines:12, decoration: const InputDecoration(hintText:'Текст заметки…'))," \
"      const SizedBox(height:12)," \
"      Row(children:[" \
"        Expanded(child: FilledButton.icon(onPressed: (){" \
"          final raw=_ctrl.text.trim(); final text= raw.isEmpty? '': raw;" \
"          final note=(widget.note?? Note.newNote());" \
"          note.text=text; note.colorHex=_color?.value; note.updatedAt=DateTime.now().millisecondsSinceEpoch;" \
"          Navigator.of(context).pop(note);" \
"        }, icon: const Icon(Icons.check), label: const Text('Сохранить')))," \
"        const SizedBox(width:12)," \
"        Expanded(child: OutlinedButton.icon(onPressed: ()=> Navigator.of(context).maybePop(), icon: const Icon(Icons.close), label: const Text('Отмена')))," \
"      ])," \
"    ]));" \
"  }" \
"}" \
"" \
"class _ColorDot extends StatelessWidget{" \
"  final Color? color; final bool selected; final VoidCallback onTap; final String? label;" \
"  const _ColorDot({required this.color, required this.selected, required this.onTap, this.label});" \
"  @override Widget build(BuildContext context){" \
"    final border= Theme.of(context).colorScheme.outlineVariant;" \
"    return InkWell(onTap:onTap, borderRadius: BorderRadius.circular(999), child: Row(mainAxisSize: MainAxisSize.min, children:[" \
"      Container(width:28, height:28, decoration: BoxDecoration(color: color?? Colors.transparent, shape: BoxShape.circle, border: Border.all(color: selected? Theme.of(context).colorScheme.primary: border, width: selected? 2:1)), child: color==null? const Center(child: Icon(Icons.close, size:16)): null)," \
"      if(label!=null) ...[ const SizedBox(width:6), Text(label!, style: Theme.of(context).textTheme.bodySmall) ]" \
"    ]));" \
"  }" \
"}" \
"" \
"List<Color> _palette()=> const [" \
"  Color(0xFFE57373), Color(0xFFF06292), Color(0xFFBA68C8), Color(0xFF9575CD)," \
"  Color(0xFF7986CB), Color(0xFF64B5F6), Color(0xFF4FC3F7), Color(0xFF4DD0E1)," \
"  Color(0xFF4DB6AC), Color(0xFF81C784), Color(0xFFAED581), Color(0xFFDCE775)," \
"  Color(0xFFFFF176), Color(0xFFFFD54F), Color(0xFFFFB74D), Color(0xFFFF8A65)," \
"  Color(0xFFA1887F), Color(0xFF90A4AE)," \
"];" \
"" \
"String _firstLine(String t){ final ls=t.trim().split('\\n'); return ls.isEmpty? '': ls.first.trim(); }" \
"String _restText(String t){ final ls=t.trim().split('\\n'); if(ls.length<=1) return ''; return ls.skip(1).join('\\n').trim(); }" \
"String _pad(int n)=> n.toString().padLeft(2,'0');" \
"String _format(DateTime dt){ final now=DateTime.now(); final sameDay= dt.year==now.year && dt.month==now.month && dt.day==now.day; return sameDay? '${_pad(dt.hour)}:${_pad(dt.minute)}' : '${_pad(dt.day)}.${_pad(dt.month)}.${dt.year}'; }" \
            >> lib/main.dart
          fi
          echo "== HEAD of lib/main.dart =="
          sed -n '1,120p' lib/main.dart

      - name: Install dependencies
        script: |
          flutter pub add shared_preferences || true
          flutter pub get

      - name: Build release APK
        script: |
          flutter clean
          flutter build apk --release

    artifacts:
      - build/app/outputs/flutter-apk/**/*.apk
